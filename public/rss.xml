<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Filipe Lima</title>
        <link>https://datsfilipe.dev</link>
        <description>Filipe Lima Blog</description>
        <lastBuildDate>Fri, 26 May 2023 12:35:54 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <copyright>CC BY-NC-SA 4.0 @ Filipe Lima</copyright>
        <item>
            <title><![CDATA[Me, animes and this blog]]></title>
            <link>https://datsfilipe.dev/blog/me-animes-and-this-blog</link>
            <guid>https://datsfilipe.dev/blog/me-animes-and-this-blog</guid>
            <pubDate>Thu, 18 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Consider this an introductory post rather than a regular one.]]></description>
            <content:encoded><![CDATA[<p>Animes has been a significant part of my life since childhood. From my early days watching <em>Naruto</em> and <em>Dragon Ball</em>, my current favorites include <em>One Piece</em>, <em>Evangelion</em> and <em>Code Geass</em>. Today, I want to delve into how animes serves as a powerful source of motivation, driving individuals to strive for excellence. One recent anime that particularly resonated with me is Blue Lockâ€”I became an ardent fan of this series.</p>
<p>The motivation I speak of is the kind that fuels one's desire to excel, to become better at something and ultimately, the best version of oneself. This is precisely the journey I am embarking on. I aspire to embark on my own hero's journey, venturing into the wilderness of programming, and sharing technology-related content through this blog. While it won't be solely focused on programming, it will predominantly revolve around this subject.</p>
<h2>This blog isn't for you</h2>
<p>I want to clarify that this blog is primarily for my personal growth and self-expression. Although you may find the posts interesting, they are not specifically tailored for you. Inspired by a creator called <em>Fabio Akita</em>, who I've followed since the beginning of my programming journey, I aim to create content that reflects my own vision. <em>Akita</em>, through his YouTube channel, compares this approach to <em>Henry Jones' diary</em> in the <em>Indiana Jones</em> films. Similarly, I hope to achieve the same level of authenticity and personal connection through this blog. Additionally, I do hope that potential recruiters visiting this blog can easily recognize my programming skills and consider me for employment opportunities.</p>
<p>Consider this an introductory post rather than a regular one. Going forward, I plan to share intriguing developments in my journey of learning Rust, most likely over the weekends. Thank you for taking the time to read, and I wish you a pleasant day, afternoon, or night ahead.</p>
]]></content:encoded>
            <author>datsfilipe@skiff.com (Filipe Lima)</author>
            <enclosure url="https://datsfilipe.dev/api/og?title=Me, animes and this blog" length="0" type="image//api/og"/>
        </item>
        <item>
            <title><![CDATA[Exploring Type Theory and Rust in my Learning Journey]]></title>
            <link>https://datsfilipe.dev/blog/my-first-steps-in-rust-and-type-theory</link>
            <guid>https://datsfilipe.dev/blog/my-first-steps-in-rust-and-type-theory</guid>
            <pubDate>Fri, 26 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Embarking on my journey of exploring Type Theory and the Rust programming language.]]></description>
            <content:encoded><![CDATA[<p><em>This is all taken from study notes of mine. I'm not an expert in Rust or Type Theory, so if you find any mistake, please let me know.</em></p>
<h2>Type Theory</h2>
<p>In general, Type Theory is the study of type systems, encompassing a vast and extensive subject. In this post, we will delve into some smaller topics that are included within it.</p>
<p>So, what are types? Essentially, types are groups created to define the expected behavior of values. To illustrate, consider the group <strong>int</strong>. Values belonging to the <strong>int</strong> group cannot be concatenated as <strong>strings</strong>. Therefore, we expect the following operation: <code>&quot;hello world&quot; + 1</code> to throw an error.</p>
<p>Programming languages can be categorized as either dynamically or statically typed. Dynamic typed languages perform type-checking at runtime, while static typed languages do so at compile time.</p>
<h3>Type Systems</h3>
<p>A Type System consists of a set of rules, known as <strong>judgements</strong>, which define the safe behaviors of typed values. These rules aim to assign a type $t$ to an expression $e$. Symbolically, we can write it as $\vdash e : t$. The Greek letter $\vdash$ before the expression is called a turnstile. In this context, it signifies that $e$ follows $t$.</p>
<h3>Inference and Type Environments</h3>
<p>Inference is the process of deducing the type of an expression. For example, a type of a variable can be inferred by the type of the value assigned to it. It's necessary to keep track of the variables's types as they are defined. That's what we call the <strong>typying environment</strong>. Symbolically it'll be represented by Gamma ($\Gamma$).</p>
<p>Based on that, we can define the following rule:</p>
<p>$$<br>
\frac{\Gamma (x) = t}{\Gamma \vdash x : t}<br>
$$</p>
<p>This is an example of an inference rule. In inference rules, if everything on the top of the fraction is true, then the bottom is also true. Another example of an inference rule, but more complex, is the following, where we type an operation between $e_1$ and $e_2$, two values from type <strong>int</strong>:</p>
<p>$$<br>
\frac{\Gamma \vdash e_1 : int \quad \Gamma \vdash e_2 : int}{\Gamma \vdash e_1 + e_2 : int}<br>
$$</p>
<h3>Axioms</h3>
<p>Axioms are the base of the inference rules. They are the rules that don't depend on anything else to be true. For example, the following rule is an axiom:</p>
<p>$$<br>
\frac{}{\Gamma \vdash 1 : int}<br>
$$</p>
<p>We can understand axioms as <strong>base cases</strong>. Also, symbolically, as you saw, they are represented by a fraction with nothing on the top. The reason is if there's nothing on the top, so everything on the top is true, this implies that also everything on the bottom is <strong>always</strong> true.</p>
<p><em>If those explanations were not clear enough, I recommend you to read <a href="https://mukulrathi.com/create-your-own-programming-language/intro-to-type-checking/">this article</a> that explains it in a very simple way.</em></p>
<h2>Linearity</h2>
<p>Linearity pertains to the property of a type system that imposes restrictions on the usage of resources, such as variables and file descriptors. To gain a better understanding of linearity, it is useful to explore what it is not.</p>
<h3>Structural Rules</h3>
<p>In proof theory, a structural rule is an inference rule that does not involve any logical connective, but rather operates directly on <strong>judgments</strong> or <strong>sequents</strong>. There are three common structural rules:</p>
<ul>
<li><strong>Weakening</strong>: The hypothesis of a sequent can be extended by adding a new formula to the left or right of the turnstile. For example:</li>
</ul>
<p>$$<br>
\frac{\Gamma \vdash \varSigma}{\Gamma \vdash \varSigma, A}<br>
$$</p>
<blockquote>
<p><em>This rule allows $A$, the resource, to be used zero times.</em></p>
</blockquote>
<ul>
<li><strong>Contraction</strong>: Equal (or unifiable) members on the same side of a sequent can be replaced by a single member or common instance. For example:</li>
</ul>
<p>$$<br>
\frac{\Gamma \vdash A, A, \varSigma}{\Gamma \vdash A, \varSigma}<br>
$$</p>
<blockquote>
<p><em>This rule allows $A$, the resource, to be used more than once.</em></p>
</blockquote>
<ul>
<li><strong>Exchange</strong>: Two members on the same side of a sequent can be swapped. For example:</li>
</ul>
<p>$$<br>
\frac{\Gamma_1, A, \Gamma_2, B, \Gamma_3 \vdash \varSigma}{\Gamma_1, B, \Gamma_2, A, \Gamma_3 \vdash \varSigma}<br>
$$</p>
<blockquote>
<p><em>This rule allows $A$ and $B$, the resources, to be used in any order.</em></p>
</blockquote>
<h3>Substructural Type System</h3>
<p>Several type systems have emerged by discarding some structural rules. The most common ones are:</p>
<table>
<thead>
<tr>
<th>Type System</th>
<th>Weakening</th>
<th>Contraction</th>
<th>Exchange</th>
<th>Use of resources</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ordered</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Exactly once in order</td>
</tr>
<tr>
<td>Linear</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Exactly once</td>
</tr>
<tr>
<td>Affine</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>At most once</td>
</tr>
</tbody>
</table>
<p>The list still goes on, but we will only need to focus on the <strong>affine</strong> type system.</p>
<h3>Affine Type System</h3>
<p>Affine logic is a substructural logic whose proof theory rejects the structural rule of <strong>contraction</strong>. It can also be characterized as <strong>linear logic</strong> with <strong>weakening</strong>.</p>
<p>The reason affine is here is because it's the type system that Rust uses. So, what does it mean? It means that Rust will not allow you to use a  more than once. To gain a better understanding of how Rust utilizes affine logic for resource management, let's delve deeper.</p>
<h2>Rust Ownership</h2>
<p>In contrast to other programming languages that employ either garbage collection or manual memory management, Rust offers a third option. Ownership is a fundamental concept in Rust, signifying that data has a single exclusive owner. When data is moved, ownership is transferred.</p>
<p>For example, consider the following code in which we attempt to move a value from one variable to another multiple times:</p>
<pre><code class="language-rust">fn main() {
  let x = Noob {};
  let y = x;
  let z = x;
}

struct Noob {}
</code></pre>
<p>If variable <code>x</code> had a type that implements the <code>Copy</code> trait, this would be permissible. However, since it does not, an error occurs, indicating that <code>x</code> was moved to <code>y</code> and cannot be used further.</p>
<h3>Borrowing</h3>
<p>To address such errors, Rust provides the concept of <strong>borrowing</strong>. Borrowing allows us to temporarily borrow a value from a variable. Consider the revised code that fixes the previous error:</p>
<pre><code class="language-rust">fn main() {
  let x = Noob {};
  let y = &amp;x;
  let z = &amp;x;
}

struct Noob {}
</code></pre>
<p>In this case, we are borrowing <code>x</code> to <code>y</code> and <code>z</code>. Borrowing in Rust can present certain challenges, especially when we face <strong>mutable</strong> and <strong>immutable</strong> variables. However, for the purpose of this blog post, we will not be focusing on this matter.</p>
<p>How do these Rust concepts work their magic? They seem to manage memory without the programmer's explicit intervention and without relying on a garbage collector. What implements those concepts is called <strong>Borrow Checker</strong>.</p>
<h2>Borrow Checker</h2>
<p>The borrow checker is a compiler feature in Rust that verifies whether the code adheres to the ownership and borrowing rules.</p>
<p>With the borrow checker and the implemented concepts, Rust can ensure memory safety to a great extent (following affine logic, resource usage is <strong>at most once</strong>). The borrow checker automatically deallocates resources that go out of scope.</p>
<h2>Conclusion</h2>
<p>Rust is a fascinating language, and the concepts surrounding the implementation of the borrow checker are equally interesting. Likewise, Type Theory presents a captivating field of study. I am enthusiastic about delving further into these topics and sharing new knowledge through future posts.</p>
<p>The purpose of these articles is to facilitate learning and knowledge sharing. I hope you found this post enjoyable and gained new insights. In order to explore more the topics discussed in this post, I recommend to check the references below.</p>
<h2>References</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=BWuozpQ_Of8&amp;list=PLF74LNuYVoxpr0xqE1ib0a9C4JgXLNtP8">From Linear Types to Rust - Eduardo Rafael Stream Recording on Youtube</a></li>
<li><a href="https://mukulrathi.com/create-your-own-programming-language/intro-to-type-checking/">An Accessible Introduction to Type Theory and Implementing a Type-Checker</a></li>
<li><a href="https://en.wikipedia.org/wiki/Structural_rule">Structural Rule</a></li>
<li><a href="https://en.wikipedia.org/wiki/Substructural_type_system">Substructural Type System</a></li>
<li><a href="https://blog.logrocket.com/understanding-ownership-in-rust/">Understanding Ownership in Rust</a></li>
</ul>
]]></content:encoded>
            <author>datsfilipe@skiff.com (Filipe Lima)</author>
            <enclosure url="https://datsfilipe.dev/api/og?title=Exploring Type Theory and Rust in my Learning Journey" length="0" type="image//api/og"/>
        </item>
    </channel>
</rss>